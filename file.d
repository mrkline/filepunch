module filepunch.file;

import std.range;

import filepunch.linuxio : FileInfo;

immutable kilo = 1024;
immutable mega = kilo * 1024;
immutable giga = mega * 1024;

/** Takes a number of bytes and returns a human-readable value
 * in bytes, KB, MB, or GB
 *
 * This is a terribly poor imitation of -h output of du,
 * as generated by gnulib's human_readable.
 */
string toHuman(real bytes)
{
    import std.format;
    string prefix;

    if (bytes == 0)
        return "0";

    if (bytes >= giga) {
        bytes /= giga;
        prefix = "G";
    }
    else if (bytes >= mega) {
        bytes /= mega;
        prefix = "M";
    }
    else if (bytes >= kilo) {
        bytes /= kilo;
        prefix ="K";
    }

    if (bytes < 10 && !prefix.empty)
        return format("%.1f", bytes) ~ prefix;
    else
        return format("%.0f", bytes) ~ prefix;
}

unittest
{
    assert(toHuman(1023) == "1023");
    assert(toHuman(1024) == "1.0K");
    assert(toHuman(1024 * 5) == "5.0K");
    assert(toHuman(1024 * 11) == "11K");
    assert(toHuman(0) == "0");
    assert(toHuman(7) == "7");
}

ulong pessimalSize(const ref FileInfo fi)
{
    import std.algorithm : max;

    // Round the logical size up to the nearest block

    immutable modBlock = fi.logicalSize % fi.blockSize;
    ulong pessimal = fi.logicalSize;
    // Make sure the modulo result isn't 0, otherwise we'd just be adding
    // another full block.
    if (modBlock != 0) pessimal += fi.blockSize - modBlock;

    // In some cases (I have no idea why),
    // the actual size can be larger than the logical rounded up.
    return max(pessimal, fi.actualSize);
}

ulong possibleSavings(const ref FileInfo fi, ulong zeroSpace)
{
    if (zeroSpace == 0) return 0;

    immutable optimal = pessimalSize(fi) - zeroSpace;

    // The amount of space we can save is the difference between the optimal
    // size and the current (actual) size, provided the value is positive.
    return fi.actualSize <= optimal ? 0 : fi.actualSize - optimal;
}
