module filepunch.file;

import std.range;

import filepunch.linuxio : FileInfo;

immutable kilo = 1024;
immutable mega = kilo * 1024;
immutable giga = mega * 1024;

/** Takes a number of bytes and returns a human-readable value
 * in bytes, KB, MB, or GB
 *
 * This is a terribly poor imitation of -h output of du,
 * as generated by gnulib's human_readable.
 */
string toHuman(real bytes)
{
    import std.format;
    string prefix;

    if (bytes == 0)
        return "0";

    if (bytes >= giga) {
        bytes /= giga;
        prefix = "G";
    }
    else if (bytes >= mega) {
        bytes /= mega;
        prefix = "M";
    }
    else if (bytes >= kilo) {
        bytes /= kilo;
        prefix ="K";
    }

    if (bytes < 10 && !prefix.empty)
        return format("%.1f", bytes) ~ prefix;
    else
        return format("%.0f", bytes) ~ prefix;
}

unittest
{
    assert(toHuman(1023) == "1023");
    assert(toHuman(1024) == "1.0K");
    assert(toHuman(1024 * 5) == "5.0K");
    assert(toHuman(1024 * 11) == "11K");
    assert(toHuman(0) == "0");
    assert(toHuman(7) == "7");
}

size_t pessimalSize(const ref FileInfo fi)
{
    import std.algorithm : max;

    // The largest the file could be is the max of its actual size or,
    // if the file is sparse, its logical size rounded up to the nearest block.
    return max(fi.logicalSize + (fi.blockSize - fi.logicalSize % fi.blockSize),
               fi.actualSize);
}

size_t possibleSavings(const ref FileInfo fi, size_t zeroSpace)
{
    immutable optimal = pessimalSize(fi) - zeroSpace; // The smallest it could be

    // The amount of space we can save is the difference between the optimal
    // size and the current (actual) size, provided the value is positive.
    return fi.actualSize <= optimal ? 0 : fi.actualSize - optimal;
}
