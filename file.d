module filepunch.file;

import std.exception;
import std.string : toStringz;

import core.sys.posix.sys.types;
import core.sys.posix.fcntl;
import core.sys.posix.sys.stat;
import core.sys.posix.unistd;
import core.sys.posix.stdio;
import core.sys.linux.errno;

extern (C) int fallocate(int fd, int mode, off_t offset, off_t len);

immutable kilo = 1024;
immutable mega = kilo * 1024;
immutable giga = mega * 1024;

/** Takes a number of bytes and returns a human-readable value
 * in bytes, KB, MB, or GB
 *
 * This is a terribly poor imitation of -h output of du,
 * as generated by gnulib's human_readable.
 */
string toHuman(double bytes)
{
    import std.format;
    string prefix;

    if (bytes >= giga) {
        bytes /= giga;
        prefix = "G";
    }
    else if (bytes >= mega) {
        bytes /= mega;
        prefix = "M";
    }
    else if (bytes >= kilo) {
        bytes /= kilo;
        prefix ="K";
    }

    if (bytes < 10)
        return format("%.1f", bytes) ~ prefix;
    else
        return format("%.0f", bytes) ~ prefix;
}

unittest
{
    assert(toHuman(1023) == "1023");
    assert(toHuman(1024) == "1.0K");
    assert(toHuman(1024 * 5) == "5.0K");
    assert(toHuman(1024 * 11) == "11K");
}

int openToRead(string path)
{
    auto fd = open(path.toStringz, O_RDONLY);
    enforce(fd >= 0, "failed to open " ~ path);
    return fd;
}

struct FileInfo {
    size_t logicalSize;
    size_t actualSize;
    size_t blockSize;
}

FileInfo getFileInfo(int fd)
{
    stat_t ss;
    enforce(fstat(fd, &ss) == 0, "fstat failed");

    FileInfo ret;
    ret.logicalSize = ss.st_size;
    ret.actualSize = ss.st_blocks * 512;
    ret. blockSize = ss.st_blksize;

    return ret;
}

struct ZeroRun {
    size_t start;
    size_t length;
}

auto getZeroRuns(int fd, const ref FileInfo fi)
{
    import core.stdc.stdlib : malloc, free;
    import std.algorithm : all;
    import std.range;
    import std.traits : ReturnType;

    static struct BlockResults {
        bool isAllZeroes;
        ReturnType!read amountRead;
    }

    static struct PossibleHoleFinder {
        this(int _fd, size_t bs) {
            fd = _fd;
            bb = new ubyte[bs];
            popFront();
        }

        @property auto ref front() { return curr; }

        void popFront()
        {
            enforce(!empty, "You cannot pop an empty range.");
            BlockResults br;
            do {
                br = readBlock();
            } while (br.amountRead > 0 && !br.isAllZeroes);

            // If we hit EOF, we're empty.
            if (br.amountRead == 0) {
                bb = null;
                return;
            }

            // Otherwise we just hit the start of a new run of zeroes
            curr.start = lseek(fd, 0, SEEK_CUR) - br.amountRead;
            curr.length = br.amountRead;

            // Keep reading until we hit EOF or stop getting zeroes
            while(true) {
                br = readBlock();
                if (br.amountRead == 0 || !br.isAllZeroes)
                    return;

                curr.length += br.amountRead;
            }
        }

        @property bool empty() { return bb is null; }

    private:
        int fd;
        ubyte[] bb;
        ZeroRun curr;

        BlockResults readBlock() {
            assert(bb !is null);
            BlockResults ret;
            ret.amountRead = read(fd, &bb[0], bb.length);
            enforce(ret.amountRead >= 0, "read() failed.");
            ret.isAllZeroes = all!(b => b == 0)(bb);
            return ret;
        }
    }
    static assert(isInputRange!PossibleHoleFinder);

    return PossibleHoleFinder(fd, fi.blockSize);
}
